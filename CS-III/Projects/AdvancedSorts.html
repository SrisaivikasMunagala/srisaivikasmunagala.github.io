<!DOCTYPE htmls <html lang="en">
<head>
  <link rel-"preconnect" href="https://fonts.googleapis.com"> <link rel-"preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googLeapis.com/css2?family=Comfortaa:wght@300;500;600&display=swap" rel="stylesheet"> <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Advanced Sorts</title>






  <link rel="stylesheet" href="../../style.css">
</head>
<body>
  <h1>Merge Sorts</h1>
  <p>Merge Sort is a sorting algorithm that follows the divide and conquer approach. It works by dividing an unsorted list into smaller sublists, sorting these sublists, and then merging them back together to produce a sorted list. The idea is to repeatedly split the list until you have smaller pieces that are easier to sort and then combine them in a sorted way. Merge Sort has a time complexity of O(n log n) in the worst, average, and best cases, making it efficient for large datasets.</p>
  <br>
  <h1>Quick Sort</h1>
  <p>Quicksort is another divide and conquer sorting algorithm. It works by selecting a pivot element from the array and partitioning the other elements into two sub-arrays, those less than the pivot and those greater than the pivot. The sub-arrays are then sorted. Quicksort's time complexity is generally O(n log n) in the average case, which is highly efficient, but it can go down to O(n^2) in the worst case if the pivot selection is not optimized.</p>
  <br>
  <h1>Heapsort</h1>
  <p>Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It first builds a max-heap (or min-heap, depending on the sorting order required) from the unsorted array. Then, it repeatedly removes the maximum (or minimum) element from the heap and adds it to the sorted portion of the array. Heapsort has a consistent time complexity of O(n log n) in all cases, making it efficient for sorting large datasets.</p>
